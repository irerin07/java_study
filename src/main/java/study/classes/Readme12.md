#### Annotation

- 애노테이션 정의하는 방법
- @retention
- @target
- @documented
- 애노테이션 프로세서

##### 애노테이션?

- 무언가 동작을 하거나 작동하는 코드가 아니라 단지 표시를 해놓는 것
- 런타임 중에 알아내야 하는 값은 들어갈 수 없고 컴파일러 수준에서 해석이 되거나 완전히 정적이여야 한다.

##### 탄생 배경?

- 우리는 기존의 자바 웹 애플리케이션에서 구성과 설정값을 XML 설정 파일을 통해 명시하고 관리하였다. <br/> 이는 변경될 수 있는 데이터들을 코드가 아닌 외부 파일로 분리함으로써 컴파일 없이 변경사항을
  적용하기 위함이었는데.. <br/> 이런 방법이 프로그램 작성 때마다 많은 설정을 작성해야 하는 불편함을 낳게 되었다. <br/> 웹 애플리케이션이 커짐에 따라 이는 더 극대화되었고 결국 이를 해결하기 위한
  방법이 필요하게 되었다. <br/> 그리고 그 방법으로 나온 것이 바로 어노테이션이다.

##### 애노테이션 정의

- 애노테이션 타입 정의하기 애노테이션을 정의하는 방법은 간단하다. @ 기호를 붙이는 것을 제외하면 인터페이스를 정의하는 것과 동일하다.

```java

@interface 애노테이션이름 {
    타입 요소이름();  // 애노테이션의 요소를 선언.
}
```

- **엄밀히 말해서 @Override는 애노테이션이고 Override는 애노테이션의 타입이다.**

##### 애노테이션의 요소

- 애노테이션 내에 선언된 메서드를 애노테이션의 요소(element)라고 한다.
- 애노테이션에도 인터페이스처럼 상수를 정의할 수 있지만, 디폴트 메서드는 정의할 수 없다.

###### 애노테이션 요소의 규칙

- 요소의 타입은 기본형, String, enum, 애노테이션, Class만 허용된다.
- ( )안에 매개변수를 선언할 수 없다.
- 예외를 선언할 수 없다.
- 요소를 타입 매개변수로 정의할 수 없다.
- 애노테이션의 요소는 반환값이 있고 매개변수는 없는 추상 메서드의 형태를 가지며, 상속을 통해 구현하지 않아도 된다.

###### 빌트인 어노테이션

- 빌트인 어노테이션이란 자바에서 기본적으로 제공해주는 어노테이션으로 <br/>
  컴파일러 경고 및 에러를 생성하여 코드를 형식에 맞게 제한한다. <br/>
  그렇기에 프로그래램의 오류를 방지할 수 있도록 일관되게 적용하는 것이 좋다. <br/>
  java.lang 패키지에 속하며, 총 6개의 어노테이션이 존재한다.

1. @Override - 선언한 메서드가 오버라이드 되었다는 것을 나타낸다. <br/>
   만약, 상위 클래스 또는 인터페이스에서 해당 메서드를 찾을 수 없다면 컴파일 에러를 발생 시킨다.
2. @Deprecated - 메소드를 사용하지 않는 것이 좋다고 권유를 한다. <br/>
   만약 사용한다면 경고를 일으킨다.
3. @SuppressWarnings - 컴파일 경고를 무시하고 실행되도록 한다.
4. @SafeVarargs - 제너릭과 같은 가변인자 매개변수를 사용할 때의 경고를 무시한다.
5. @FunctionalInterface - 함수형 인터페이스인지를 검사한다. <br/>
   즉, 메소드가 없거나 두개 이상 되면 컴파일 오류가 난다 람다를 위한 인터페이스를 지정하는 것이기도 하다.
6. @Native - 어노테이션이 달린 필드가 네이티브 코드에서 참조할 수있는 상수임을 나타낸다.

###### 메타 어노테이션

- 메타 어노테이션이란 어노테이션을 정의할 때, 어노테이션에 대한 부가적인 기능이나 제약조건을 정의하기 위한 어노테이션이다.

1. @Target Annotation이 적용될 범위를 지정한다. <br/>
   value값으로는 ElementType의 enum상수값이 사용되며 다중 선택도 가능하다.
2. @Retention Annotation 의 LifeCycle을 지정한다. <br/>
   즉, 어노테이션이 메모리에 유지되는 시간을 지정한다. <br/>
   value값으로는 RententionPolicydml enum상수값이 사용된다.
3. @Inherited 어노테이션이 하위 클래스에서도 적용될 수 있도록 상속된다.
4. @Documented JavaDoc 생성시 Annotation에 대한 정보도 함께 생성한다.
5. @Repeatable 지정한 어노테이션을 사용처에서 중복해서 정의할 수 있게끔 해준다.

###### @Retention

- 어노테이션이 유지되는 기간(Life Time)을 설정하는 어노테이션

```java
public enum RetentionPolicy {
    SOURCE,
    CLASS,
    RUNTIME
}
```

- SOURCE : 소스파일에만 존재하고, 클래스파일에는 존재x, 컴파일러에 의해 버려진다.

- CLASS : 클래스파일에는 존재하지만 런타임 시에 유지할 필요 없다는 것을 알리고 이 값이 default이다.

- RUNTIME : 클래스파일에도 존재하고 런타임애 VM에 의해 유지되어 리플랙션을 통해 클래스 파일의 정보를 읽어 처리 가능하다.


*SOURCE → CLASS → RUNTIME*

- `**SOURCE`** 는 소스코드에만 유지하겠다.
    - 컴파일 시에만 사용하겠다는 의미 !
    - 컴파일 하고 나면 애노테이션은 없어진다.

        → 필요없으니까!, 바이트 코드에 남아있지도 않다.

- `**CLASS**`
    - 애노테이션에 대한 정보를 클래스 파일까지, 즉 바이트 코드에도 남겨 두겠다.
    - 클래스 정보를 읽어들이는 방법(바이트 코드를 읽어들이는)을 바탕으로 애노테이션 정보를 읽어와서 처리할 수 있다.
        - 예) BYTE BUDDY, ASM 활용
    - 바이트 코드엔 남아 있지만, ***이 클래스파일을 JVM이 실행할 때 클래스에 대한 정보를 클래스로더가 읽어서 메모리에 적재하게되고,*** *이후 사용 시점에 메모리에서 읽어올 때 애노테이션 정보를 제외하고 읽어옴*

- **`RUNTIME`**
    - 위 CLASS와 동일하지만, ***메모리에 적재된 클래스 정보를 읽어올 때 애노테이션 정보를 그대로 포함하는 것이다.***

###### @target
- 애노테이션이 적용가능한 대상을 지정하는데 사용한다. 
  - 여러 개의 값을 지정할 때는 배열에서처럼 괄호{ }를 사용해야 한다.

- @Target으로 지정할 수 있는 애노테이션 적용대상의 종류

기존
- TYPE : Class, Interface(어노테이션 타입 포함), enum, jdk14에 생긴 record

- FIELD : 필드 값(프로퍼티), enum 상수값
- METHOD : 메서드

- PARAMETER : 메서드 파라미터 (매개 변수)

- CONSTRUCTOR : 생성자

- LOCAL_VARIABLE : 지역 변수

- ANNOTATION_TYPE : 어노테이션

- PACKAGE : 자바 패키지

jdk 1.8 이후 추가
- TYPE_PARAMETER : 타입 매개 변수

- TYPE_USE : 타입 사용 //jdk 9 이후

- MODULE : 모듈

jdk 14이후 추가
- RECORD_COMPONENT : Record 컴포넌트

- ‘TYPE’은 타입을 선언할 때 애노테이션을 붙일 수 있다는 뜻이고, ‘TYPE_USE’는 해당 타입의 변수를 선언할 때 붙일 수 있다는 뜻이다. 위 표에 나오는 값들은 java.lang.annotation.ElementType라는 열거형에 정의되어 있다.

###### @documented
@Documented는 애노테이션에 대한 정보가 javadoc으로 작성한 문서에 포함되도록한다. 자바에서 제공하는 기본 애노테이션 중에서 @Override와 @SuppressWarnings을 제외하면 모두 @Documented가 붙어 있다.

##### 어노테이션 프로세서
- 어노테이션 프로세서는 자바 컴파일러 플러그인의 일종으로 어노테이션에 대한 코드베이스를 검사, 수정, 생성하는 역할을 가지는 플러그인

###### 애노테이션 프로세서 장점
- 애노테이션 프로세서는 애플리케이션을 구동하는 런타임 시점이 아니라, 컴파일 시점에 조작하여 사용함으로 런타임에 대한 비용이 제로가 된다.
###### 애노테이션 프로세서 단점
- 롬복 같은 경우 기존 코드를 변경하는 방법이지만 공개된 API가 아닌 컴파일러 내부 클래스를 사용하여 기존 소스 코드를 조작하기 때문에 해킹에 가깝다고 할 수 있다.
- **애노테이션 프로세서를 직접 작성하거나 혹은 만들어진 애노테이션 프로세서를 확인하면 한 가지 알 수 있는 사실은 AbstractProcessor 클래스를 상속받는 것이다.**



######  ServiceLoader는 무엇인가

```java

public interface HelloService {

    String hello();

}
```

- 이렇게 인터페이스가 있고 나는 이러한 인터페이스만 제공한다고 생각해보자. 
- 구현체는 구글에서 만들 수도 있고, 네이버에서 만들 수도 있고, 카카오나 우형에서 만들 수도 있다. 
- 제각각의 jar파일로 만들텐데, 인터페이스의 구현체를 내가 만들지 않고 jar파일만 바꾸면 해당 인터페이스 타입을 구현한 구현체의 인스턴스를 가져올 수 있는 방법이 바로 ServiceLoader이다.


- 그렇다면 이 서비스 구현체들을 어떻게 찾을 것이냐? 인터페이스를 사용하는 구현체의 resources폴더에 META-INF/services를 만들고 그 안에 인터페이스의 풀패키지 경로를 이름으로 하는 파일을 만들어준다. 
- 그리고 내용으로 구현체의 풀패키지 경로를 작성한다. 다 되었다면 패키징을 한 후 사용할 프로젝트에서 dependency로 추가해주자.

자! 거의 다 왔다. 이렇게 추가해주면 직접 참조하지 않아도 사용할 수 있게 되는데, 이제 ServiceLoader를 이용하여 확인할 수 있다.
```java
public class HelloMain {
public static void main(String[] args) {
ServiceLoader<HelloService> loader = ServiceLoader.load(HelloService.class);

        for(HelloService helloService : loader) {
            System.out.println(helloService.hello());
        }
    }
}
```

- for문을 사용했기 때문에 jar파일이 여러 개라도 다 읽어올 수 있다.

###### 싱글 값 애노테이션
```java
@Inherited
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface CustomUserAnnotation {
String value();
}

class Sample{
@CustomUserAnnotation("gracenam")
public void go(){
System.out.println("annotationTest");
}
}
```
- 어노테이션 멤버의 이름을 value( )로 주었을 경우, 외부에서 호출시 ( )에 멤버 = 형식을 생략할 수 있다.